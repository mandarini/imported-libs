{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.extractComponentDescription = exports.extractArgTypes = exports.extractArgTypesFromData = exports.extractType = exports.findComponentByName = exports.checkValidCompodocJson = exports.checkValidComponentOrDirective = exports.getCompodocJson = exports.setCompodocJson = exports.isMethod = void 0;\n/* eslint-disable no-underscore-dangle */\nconst global_1 = require(\"@storybook/global\");\nconst client_logger_1 = require(\"@storybook/client-logger\");\nconst isMethod = methodOrProp => {\n  return methodOrProp.args !== undefined;\n};\nexports.isMethod = isMethod;\nconst setCompodocJson = compodocJson => {\n  global_1.global.__STORYBOOK_COMPODOC_JSON__ = compodocJson;\n};\nexports.setCompodocJson = setCompodocJson;\nconst getCompodocJson = () => global_1.global.__STORYBOOK_COMPODOC_JSON__;\nexports.getCompodocJson = getCompodocJson;\nconst checkValidComponentOrDirective = component => {\n  if (!component.name) {\n    throw new Error(`Invalid component ${JSON.stringify(component)}`);\n  }\n};\nexports.checkValidComponentOrDirective = checkValidComponentOrDirective;\nconst checkValidCompodocJson = compodocJson => {\n  if (!compodocJson || !compodocJson.components) {\n    throw new Error('Invalid compodoc JSON');\n  }\n};\nexports.checkValidCompodocJson = checkValidCompodocJson;\nconst hasDecorator = (item, decoratorName) => item.decorators && item.decorators.find(x => x.name === decoratorName);\nconst mapPropertyToSection = item => {\n  if (hasDecorator(item, 'ViewChild')) {\n    return 'view child';\n  }\n  if (hasDecorator(item, 'ViewChildren')) {\n    return 'view children';\n  }\n  if (hasDecorator(item, 'ContentChild')) {\n    return 'content child';\n  }\n  if (hasDecorator(item, 'ContentChildren')) {\n    return 'content children';\n  }\n  return 'properties';\n};\nconst mapItemToSection = (key, item) => {\n  switch (key) {\n    case 'methods':\n    case 'methodsClass':\n      return 'methods';\n    case 'inputsClass':\n      return 'inputs';\n    case 'outputsClass':\n      return 'outputs';\n    case 'properties':\n    case 'propertiesClass':\n      if ((0, exports.isMethod)(item)) {\n        throw new Error(\"Cannot be of type Method if key === 'propertiesClass'\");\n      }\n      return mapPropertyToSection(item);\n    default:\n      throw new Error(`Unknown key: ${key}`);\n  }\n};\nconst findComponentByName = (name, compodocJson) => compodocJson.components.find(c => c.name === name) || compodocJson.directives.find(c => c.name === name) || compodocJson.pipes.find(c => c.name === name) || compodocJson.injectables.find(c => c.name === name) || compodocJson.classes.find(c => c.name === name);\nexports.findComponentByName = findComponentByName;\nconst getComponentData = component => {\n  if (!component) {\n    return null;\n  }\n  (0, exports.checkValidComponentOrDirective)(component);\n  const compodocJson = (0, exports.getCompodocJson)();\n  if (!compodocJson) {\n    return null;\n  }\n  (0, exports.checkValidCompodocJson)(compodocJson);\n  const {\n    name\n  } = component;\n  const metadata = (0, exports.findComponentByName)(name, compodocJson);\n  if (!metadata) {\n    client_logger_1.logger.warn(`Component not found in compodoc JSON: '${name}'`);\n  }\n  return metadata;\n};\nconst displaySignature = item => {\n  const args = item.args.map(arg => `${arg.name}${arg.optional ? '?' : ''}: ${arg.type}`);\n  return `(${args.join(', ')}) => ${item.returnType}`;\n};\nconst extractTypeFromValue = defaultValue => {\n  const valueType = typeof defaultValue;\n  return defaultValue || valueType === 'number' || valueType === 'boolean' || valueType === 'string' ? valueType : null;\n};\nconst extractEnumValues = compodocType => {\n  const compodocJson = (0, exports.getCompodocJson)();\n  const enumType = compodocJson?.miscellaneous?.enumerations?.find(x => x.name === compodocType);\n  if (enumType?.childs.every(x => x.value)) {\n    return enumType.childs.map(x => x.value);\n  }\n  if (typeof compodocType !== 'string' || compodocType.indexOf('|') === -1) {\n    return null;\n  }\n  try {\n    return compodocType.split('|').map(value => JSON.parse(value));\n  } catch (e) {\n    return null;\n  }\n};\nconst extractType = (property, defaultValue) => {\n  const compodocType = property.type || extractTypeFromValue(defaultValue);\n  switch (compodocType) {\n    case 'string':\n    case 'boolean':\n    case 'number':\n      return {\n        name: compodocType\n      };\n    case undefined:\n    case null:\n      return {\n        name: 'other',\n        value: 'void'\n      };\n    default:\n      {\n        const resolvedType = resolveTypealias(compodocType);\n        const enumValues = extractEnumValues(resolvedType);\n        return enumValues ? {\n          name: 'enum',\n          value: enumValues\n        } : {\n          name: 'other',\n          value: 'empty-enum'\n        };\n      }\n  }\n};\nexports.extractType = extractType;\nconst castDefaultValue = (property, defaultValue) => {\n  const compodocType = property.type;\n  // All these checks are necessary as compodoc does not always set the type ie. @HostBinding have empty types.\n  // null and undefined also have 'any' type\n  if (['boolean', 'number', 'string', 'EventEmitter'].includes(compodocType)) {\n    switch (compodocType) {\n      case 'boolean':\n        return defaultValue === 'true';\n      case 'number':\n        return Number(defaultValue);\n      case 'EventEmitter':\n        return undefined;\n      default:\n        return defaultValue;\n    }\n  } else {\n    switch (defaultValue) {\n      case 'true':\n        return true;\n      case 'false':\n        return false;\n      case 'null':\n        return null;\n      case 'undefined':\n        return undefined;\n      default:\n        return defaultValue;\n    }\n  }\n};\nconst extractDefaultValueFromComments = (property, value) => {\n  let commentValue = value;\n  property.jsdoctags.forEach(tag => {\n    if (['default', 'defaultvalue'].includes(tag.tagName.escapedText)) {\n      const dom = new global_1.global.DOMParser().parseFromString(tag.comment, 'text/html');\n      commentValue = dom.body.textContent;\n    }\n  });\n  return commentValue;\n};\nconst extractDefaultValue = property => {\n  try {\n    let value = property.defaultValue?.replace(/^'(.*)'$/, '$1');\n    value = castDefaultValue(property, value);\n    if (value == null && property.jsdoctags?.length > 0) {\n      value = extractDefaultValueFromComments(property, value);\n    }\n    return value;\n  } catch (err) {\n    client_logger_1.logger.debug(`Error extracting ${property.name}: ${property.defaultValue}`);\n    return undefined;\n  }\n};\nconst resolveTypealias = compodocType => {\n  const compodocJson = (0, exports.getCompodocJson)();\n  const typeAlias = compodocJson?.miscellaneous?.typealiases?.find(x => x.name === compodocType);\n  return typeAlias ? resolveTypealias(typeAlias.rawtype) : compodocType;\n};\nconst extractArgTypesFromData = componentData => {\n  const sectionToItems = {};\n  const compodocClasses = ['component', 'directive'].includes(componentData.type) ? ['propertiesClass', 'methodsClass', 'inputsClass', 'outputsClass'] : ['properties', 'methods'];\n  compodocClasses.forEach(key => {\n    const data = componentData[key] || [];\n    data.forEach(item => {\n      const section = mapItemToSection(key, item);\n      const defaultValue = (0, exports.isMethod)(item) ? undefined : extractDefaultValue(item);\n      const type = (0, exports.isMethod)(item) || section !== 'inputs' && section !== 'properties' ? {\n        name: 'other',\n        value: 'void'\n      } : (0, exports.extractType)(item, defaultValue);\n      const action = section === 'outputs' ? {\n        action: item.name\n      } : {};\n      const argType = {\n        name: item.name,\n        description: item.rawdescription || item.description,\n        type,\n        ...action,\n        table: {\n          category: section,\n          type: {\n            summary: (0, exports.isMethod)(item) ? displaySignature(item) : item.type,\n            required: (0, exports.isMethod)(item) ? false : !item.optional\n          },\n          defaultValue: {\n            summary: defaultValue\n          }\n        }\n      };\n      if (!sectionToItems[section]) {\n        sectionToItems[section] = [];\n      }\n      sectionToItems[section].push(argType);\n    });\n  });\n  const SECTIONS = ['properties', 'inputs', 'outputs', 'methods', 'view child', 'view children', 'content child', 'content children'];\n  const argTypes = {};\n  SECTIONS.forEach(section => {\n    const items = sectionToItems[section];\n    if (items) {\n      items.forEach(argType => {\n        argTypes[argType.name] = argType;\n      });\n    }\n  });\n  return argTypes;\n};\nexports.extractArgTypesFromData = extractArgTypesFromData;\nconst extractArgTypes = component => {\n  const componentData = getComponentData(component);\n  return componentData && (0, exports.extractArgTypesFromData)(componentData);\n};\nexports.extractArgTypes = extractArgTypes;\nconst extractComponentDescription = component => {\n  const componentData = getComponentData(component);\n  return componentData && (componentData.rawdescription || componentData.description);\n};\nexports.extractComponentDescription = extractComponentDescription;","map":{"version":3,"names":["Object","defineProperty","exports","value","extractComponentDescription","extractArgTypes","extractArgTypesFromData","extractType","findComponentByName","checkValidCompodocJson","checkValidComponentOrDirective","getCompodocJson","setCompodocJson","isMethod","global_1","require","client_logger_1","methodOrProp","args","undefined","compodocJson","global","__STORYBOOK_COMPODOC_JSON__","component","name","Error","JSON","stringify","components","hasDecorator","item","decoratorName","decorators","find","x","mapPropertyToSection","mapItemToSection","key","c","directives","pipes","injectables","classes","getComponentData","metadata","logger","warn","displaySignature","map","arg","optional","type","join","returnType","extractTypeFromValue","defaultValue","valueType","extractEnumValues","compodocType","enumType","miscellaneous","enumerations","childs","every","indexOf","split","parse","e","property","resolvedType","resolveTypealias","enumValues","castDefaultValue","includes","Number","extractDefaultValueFromComments","commentValue","jsdoctags","forEach","tag","tagName","escapedText","dom","DOMParser","parseFromString","comment","body","textContent","extractDefaultValue","replace","length","err","debug","typeAlias","typealiases","rawtype","componentData","sectionToItems","compodocClasses","data","section","action","argType","description","rawdescription","table","category","summary","required","push","SECTIONS","argTypes","items"],"sources":["/Users/katerina/Projects/nrwl/test_nx_workspaces/imported-libs/node_modules/@storybook/angular/dist/client/docs/compodoc.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.extractComponentDescription = exports.extractArgTypes = exports.extractArgTypesFromData = exports.extractType = exports.findComponentByName = exports.checkValidCompodocJson = exports.checkValidComponentOrDirective = exports.getCompodocJson = exports.setCompodocJson = exports.isMethod = void 0;\n/* eslint-disable no-underscore-dangle */\nconst global_1 = require(\"@storybook/global\");\nconst client_logger_1 = require(\"@storybook/client-logger\");\nconst isMethod = (methodOrProp) => {\n    return methodOrProp.args !== undefined;\n};\nexports.isMethod = isMethod;\nconst setCompodocJson = (compodocJson) => {\n    global_1.global.__STORYBOOK_COMPODOC_JSON__ = compodocJson;\n};\nexports.setCompodocJson = setCompodocJson;\nconst getCompodocJson = () => global_1.global.__STORYBOOK_COMPODOC_JSON__;\nexports.getCompodocJson = getCompodocJson;\nconst checkValidComponentOrDirective = (component) => {\n    if (!component.name) {\n        throw new Error(`Invalid component ${JSON.stringify(component)}`);\n    }\n};\nexports.checkValidComponentOrDirective = checkValidComponentOrDirective;\nconst checkValidCompodocJson = (compodocJson) => {\n    if (!compodocJson || !compodocJson.components) {\n        throw new Error('Invalid compodoc JSON');\n    }\n};\nexports.checkValidCompodocJson = checkValidCompodocJson;\nconst hasDecorator = (item, decoratorName) => item.decorators && item.decorators.find((x) => x.name === decoratorName);\nconst mapPropertyToSection = (item) => {\n    if (hasDecorator(item, 'ViewChild')) {\n        return 'view child';\n    }\n    if (hasDecorator(item, 'ViewChildren')) {\n        return 'view children';\n    }\n    if (hasDecorator(item, 'ContentChild')) {\n        return 'content child';\n    }\n    if (hasDecorator(item, 'ContentChildren')) {\n        return 'content children';\n    }\n    return 'properties';\n};\nconst mapItemToSection = (key, item) => {\n    switch (key) {\n        case 'methods':\n        case 'methodsClass':\n            return 'methods';\n        case 'inputsClass':\n            return 'inputs';\n        case 'outputsClass':\n            return 'outputs';\n        case 'properties':\n        case 'propertiesClass':\n            if ((0, exports.isMethod)(item)) {\n                throw new Error(\"Cannot be of type Method if key === 'propertiesClass'\");\n            }\n            return mapPropertyToSection(item);\n        default:\n            throw new Error(`Unknown key: ${key}`);\n    }\n};\nconst findComponentByName = (name, compodocJson) => compodocJson.components.find((c) => c.name === name) ||\n    compodocJson.directives.find((c) => c.name === name) ||\n    compodocJson.pipes.find((c) => c.name === name) ||\n    compodocJson.injectables.find((c) => c.name === name) ||\n    compodocJson.classes.find((c) => c.name === name);\nexports.findComponentByName = findComponentByName;\nconst getComponentData = (component) => {\n    if (!component) {\n        return null;\n    }\n    (0, exports.checkValidComponentOrDirective)(component);\n    const compodocJson = (0, exports.getCompodocJson)();\n    if (!compodocJson) {\n        return null;\n    }\n    (0, exports.checkValidCompodocJson)(compodocJson);\n    const { name } = component;\n    const metadata = (0, exports.findComponentByName)(name, compodocJson);\n    if (!metadata) {\n        client_logger_1.logger.warn(`Component not found in compodoc JSON: '${name}'`);\n    }\n    return metadata;\n};\nconst displaySignature = (item) => {\n    const args = item.args.map((arg) => `${arg.name}${arg.optional ? '?' : ''}: ${arg.type}`);\n    return `(${args.join(', ')}) => ${item.returnType}`;\n};\nconst extractTypeFromValue = (defaultValue) => {\n    const valueType = typeof defaultValue;\n    return defaultValue || valueType === 'number' || valueType === 'boolean' || valueType === 'string'\n        ? valueType\n        : null;\n};\nconst extractEnumValues = (compodocType) => {\n    const compodocJson = (0, exports.getCompodocJson)();\n    const enumType = compodocJson?.miscellaneous?.enumerations?.find((x) => x.name === compodocType);\n    if (enumType?.childs.every((x) => x.value)) {\n        return enumType.childs.map((x) => x.value);\n    }\n    if (typeof compodocType !== 'string' || compodocType.indexOf('|') === -1) {\n        return null;\n    }\n    try {\n        return compodocType.split('|').map((value) => JSON.parse(value));\n    }\n    catch (e) {\n        return null;\n    }\n};\nconst extractType = (property, defaultValue) => {\n    const compodocType = property.type || extractTypeFromValue(defaultValue);\n    switch (compodocType) {\n        case 'string':\n        case 'boolean':\n        case 'number':\n            return { name: compodocType };\n        case undefined:\n        case null:\n            return { name: 'other', value: 'void' };\n        default: {\n            const resolvedType = resolveTypealias(compodocType);\n            const enumValues = extractEnumValues(resolvedType);\n            return enumValues\n                ? { name: 'enum', value: enumValues }\n                : { name: 'other', value: 'empty-enum' };\n        }\n    }\n};\nexports.extractType = extractType;\nconst castDefaultValue = (property, defaultValue) => {\n    const compodocType = property.type;\n    // All these checks are necessary as compodoc does not always set the type ie. @HostBinding have empty types.\n    // null and undefined also have 'any' type\n    if (['boolean', 'number', 'string', 'EventEmitter'].includes(compodocType)) {\n        switch (compodocType) {\n            case 'boolean':\n                return defaultValue === 'true';\n            case 'number':\n                return Number(defaultValue);\n            case 'EventEmitter':\n                return undefined;\n            default:\n                return defaultValue;\n        }\n    }\n    else {\n        switch (defaultValue) {\n            case 'true':\n                return true;\n            case 'false':\n                return false;\n            case 'null':\n                return null;\n            case 'undefined':\n                return undefined;\n            default:\n                return defaultValue;\n        }\n    }\n};\nconst extractDefaultValueFromComments = (property, value) => {\n    let commentValue = value;\n    property.jsdoctags.forEach((tag) => {\n        if (['default', 'defaultvalue'].includes(tag.tagName.escapedText)) {\n            const dom = new global_1.global.DOMParser().parseFromString(tag.comment, 'text/html');\n            commentValue = dom.body.textContent;\n        }\n    });\n    return commentValue;\n};\nconst extractDefaultValue = (property) => {\n    try {\n        let value = property.defaultValue?.replace(/^'(.*)'$/, '$1');\n        value = castDefaultValue(property, value);\n        if (value == null && property.jsdoctags?.length > 0) {\n            value = extractDefaultValueFromComments(property, value);\n        }\n        return value;\n    }\n    catch (err) {\n        client_logger_1.logger.debug(`Error extracting ${property.name}: ${property.defaultValue}`);\n        return undefined;\n    }\n};\nconst resolveTypealias = (compodocType) => {\n    const compodocJson = (0, exports.getCompodocJson)();\n    const typeAlias = compodocJson?.miscellaneous?.typealiases?.find((x) => x.name === compodocType);\n    return typeAlias ? resolveTypealias(typeAlias.rawtype) : compodocType;\n};\nconst extractArgTypesFromData = (componentData) => {\n    const sectionToItems = {};\n    const compodocClasses = ['component', 'directive'].includes(componentData.type)\n        ? ['propertiesClass', 'methodsClass', 'inputsClass', 'outputsClass']\n        : ['properties', 'methods'];\n    compodocClasses.forEach((key) => {\n        const data = componentData[key] || [];\n        data.forEach((item) => {\n            const section = mapItemToSection(key, item);\n            const defaultValue = (0, exports.isMethod)(item) ? undefined : extractDefaultValue(item);\n            const type = (0, exports.isMethod)(item) || (section !== 'inputs' && section !== 'properties')\n                ? { name: 'other', value: 'void' }\n                : (0, exports.extractType)(item, defaultValue);\n            const action = section === 'outputs' ? { action: item.name } : {};\n            const argType = {\n                name: item.name,\n                description: item.rawdescription || item.description,\n                type,\n                ...action,\n                table: {\n                    category: section,\n                    type: {\n                        summary: (0, exports.isMethod)(item) ? displaySignature(item) : item.type,\n                        required: (0, exports.isMethod)(item) ? false : !item.optional,\n                    },\n                    defaultValue: { summary: defaultValue },\n                },\n            };\n            if (!sectionToItems[section]) {\n                sectionToItems[section] = [];\n            }\n            sectionToItems[section].push(argType);\n        });\n    });\n    const SECTIONS = [\n        'properties',\n        'inputs',\n        'outputs',\n        'methods',\n        'view child',\n        'view children',\n        'content child',\n        'content children',\n    ];\n    const argTypes = {};\n    SECTIONS.forEach((section) => {\n        const items = sectionToItems[section];\n        if (items) {\n            items.forEach((argType) => {\n                argTypes[argType.name] = argType;\n            });\n        }\n    });\n    return argTypes;\n};\nexports.extractArgTypesFromData = extractArgTypesFromData;\nconst extractArgTypes = (component) => {\n    const componentData = getComponentData(component);\n    return componentData && (0, exports.extractArgTypesFromData)(componentData);\n};\nexports.extractArgTypes = extractArgTypes;\nconst extractComponentDescription = (component) => {\n    const componentData = getComponentData(component);\n    return componentData && (componentData.rawdescription || componentData.description);\n};\nexports.extractComponentDescription = extractComponentDescription;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}